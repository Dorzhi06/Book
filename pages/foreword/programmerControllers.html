<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Программирование микроконтролеров</title>

    <link rel="stylesheet" href="../../source/bootstrap/css/bootstrap.css">
    <link rel="stylesheet" href="../../source/bootstrap/js/bootstrap.js">
    <link rel="stylesheet" href="../../source/css/index.css">

</head>
<body>
    <h1 class="contentCenter mainText">Программирование микроконтролеров</h1>
    <p>
        В этом разделе мы поговорим о программировании
        микроконтроллеров. Точнее, как обрабатывается программа перед
        тем, как ее выполнит микроконтроллер.
        Ключевым моментом здесь является то, микроконтроллер, как 
        вы, наверное, догадываетесь, на самом деле не выполняет буквально
        тот код, который пишут программисты. Сначала он должен быть
        обработан транслятором, а затем уже он выполняется
        микроконтроллером.
    </p>
    <p>
        Зачем нужен этот дополнительный этап? Он нужен потому, что
        микроконтроллер, как и любой другой процессор, не понимает
        языков Си, или С++, Java, Паскаль, Питон и любые другие языки, на
        которых обычно пишутся программы. Он понимает и может
        выполнять только свой собственный машинный язык.
        Возьмем процессор Intel. Он понимает машинный язык X86. 
        Другие процессоры, например, микроконтроллеры Atmel, которые
        стоят на платах Arduino, понимают свой машинный язык. Различные
        семейства процессоров используют свой собственный язык. Что он из 
        себя представляет? Это набор простых инструкций, закодированных
        в двоичном формате с помощью нулей и единиц. Так что если вы
        посмотрите непосредственно на машинный код, то все, что вы
        увидите – это нули и единицы. Это, конечно, редко кто делает, но 
        если и делает, то обычно код записывается в шестнадцатеричном 
        формате – так он занимает меньше места и чуть более удобен для 
        восприятия. Но в любом случае машинный язык не выглядит
        читаемым для человека, хотя это то, что машина на самом деле
        выполняет.
    </p>
    <p>
        Для того, чтобы сделать программы более удобочитаемыми их 
        переводят на язык ассемблера, которые стоит из коротких и 
        понятных мнемонических команд, вроде ADD, SUB, MUL, MOV, JMP и т.д. 
        Никакой выразительной мощности ассемблер не добавляет, так как
        по сути, это однозначное отображение из машинных кодов в слова.
        Он существует только ради удобства чтения машинных кодов 
        человеком. Например, вместо 10110110 10111001 01100110 
        01010101 (или в шестнадцатеричном формате – B6 B9 66 55) будет 
        написано ADD R1, R2, R3, что означает сложить значения в регистрах
        R2 и R3 и поместить результат в R1.
        Хоть язык ассемблера и придумали для облегчения чтения и
        записи программ, но все-таки это очень низкий уровень.
        Ассемблерный язык называется языком с метками, потому что 
        напротив любой инструкции можно поставить метку, а затем перейти 
        к ней с помощью команд условного и безусловного перехода (вроде 
        goto в высокоуровневых языках). Причем переходы по меткам – это 
        единственный способ организовать ветвления и циклы, так как в 
        подобных языках нет ни циклов for или while, ни возможности 
        объединить инструкции в блоки кода как в структурированных 
        языках программирования. Можно писать код на языке ассемблера, 
        но это трудно, и мы не будем делать это в данном пособии. Иногда 
        это необходимо, чтобы достичь максимальной производительности. 
        Мы будем работать с языками более высокого уровня – Си, C++, 
        Python, Lua.
    </p>
    <p>
        Таким образом, программа, написанная на языке высокого
        уровня, должна быть переведена на машинный язык, прежде чем ее 
        сможет выполнить микроконтроллер. Существует два способа, 
        которыми это можно сделать, в зависимости от того, используется ли
        компилируемый или интерпретируемый язык. Если использовать
        компилируемый язык, то программа на этом языке сразу целиком
        переводится в машинный код. После такого перевода вы получите то, 
        что называется исполняемым файлом, содержащим именно тот код, 
        который выполняется каждый раз при запуске программы. Примеры 
        компилируемых языков – Си, C++, Паскаль и другие. Когда мы будем
        использовать платы Arduino, мы будем работать с упрощенным
        языком С++.
    </p>
    <p>
        С другой стороны, кроме компиляции, есть также интерпретация. 
        В интерпретируемой среде инструкции на языке высокого уровня, 
        преобразуются в машинный код каждый раз во время выполнения с 
        помощью интерпретатора. Примерами таких языков является 
        Питон, Java, Lua и другие. Недостаток интепретируемых программ в
        том, что они работают существенной медленнее, ведь процессор 
        выполняет не их, а код интерпретатора, который, в свою очередь, 
        выполняет вашу программу! Скомпилированная же программа, как 
        уже было сказано ранее, занимает центральный процессор целиком 
        и полностью без всяких посредников. Но интерпретация имеет и
        преимущества, поскольку она освобождает программиста от
        определенных задач. Так, например, если в Си вы хотите
        использовать динамический массив, вам нужно вызвать
        специальную функцию для получения памяти, а затем не забыть
        освободить эту память. Это очень сложно отследить и сделать
        корректно в больших программах, поэтому часто возникают ошибки. 
    </p>
    <p>
        С другой стороны, в интерпретируемых языках вы просто
        используете готовый динамический массив, а интерпретатор решает
        все задачи с управлением памятью. Поэтому какой язык 
        использовать, как всегда, зависит от решаемой задачи
    </p>
</body>
</html>
<h2 class="contentCenter mainText">Основные функции</h2>
<p>
  Функция – часть программы, имеющая своё название и выполняющая заданную задачу. Большая 
  программа может строиться из нескольких функций, каждая из которых выполняет свою задачу. Использование 
  функций очень сильно упрощает написание и чтение кода, и в большинстве случаев делает его оптимальным 
  по объёму занимаемой памяти. Функция должна быть описана, и после этого может вызываться. 
  Функция должна быть описана вне других функций! В общем виде функция имеет следующую структуру, т.е. описание функции:
</p>
<p>
  тип_данных имя_функции (набор_параметров) {<br>
    <тело_функции><br>
  }<br>
</p>
<p>
  Где тип данных – это тип данных, который возвращает функция, имя функции – имя, по которому функция вызывается, 
  набор параметров – необязательный набор формальных переменных, и тело функции – уже собственно набор операций. 
  Вызов функции осуществляется именем функции и передачей набора параметров, если таковые имеются:
</p>
<p>
  имя_функции(параметр1, параметр2, параметрN);
</p>
<p>
  Если параметры не передаются, нужно указать пустые скобки в любом случае!
</p>
<p>
  имя_функции();
</p>
<p>
  Функция может принимать параметры, может не принимать, может 
  возвращать какое-то значение, может не возвращать. Давайте рассмотрим эти варианты.
</p>
<p>
  Функция, которая ничего не принимает и ничего не возвращает
  Самый простой для понимания вариант, с него и начнём. Помимо типов данных, которые 
  я перечислял в уроке о типах данных, есть ещё один – void, который переводится с 
  английского как “пустота”. Создавая функцию типа void мы указываем компилятору, 
  что никаких значений возвращаться не будет (точнее будет – функция вернёт “ничего”). 
  Давайте напишем функцию, которая найдёт сумму двух чисел и присвоит её третьему числу. 
  Так как функция у нас без параметров и ничего не возвращает, переменные придётся объявить 
  заранее и сделать их глобальными, иначе функция не будет иметь к ним доступ и мы получим ошибку:
</p>
<p>
  byte a, b;<br>
  int c;<br>
  void setup() {<br>
    a = 10;<br>
    b = 20;<br>
    sumFunction();<br>
    // после вызова функции<br>
    // с имеет значение 30<br>
  }<br>
  void loop() {<br>
  }<br>
  void sumFunction() {<br>
    c = a + b;<br>
  }<br>
</p>
<p>
  Это очень плохой пример с точки зрения оптимальности кода, но далее мы 
  будем этот пример улучшать и в итоге получим конфетку. Чем он плох на 
  данном этапе: у нас используются глобальные переменные, и они же участвуют 
  внутри функции, а одним из главных принципов программирования на C++ является 
  разделение данных и действий, а также минимизация количества глобальных переменных. 
  Будучи новичком, не стоит об этом сильно задумываться, позже вы сами к этому придёте. 
  Разделяя данные и действия можно создавать универсальные инструменты, рассмотренная 
  выше функция не является универсальной: она складывает глобальную а с глобальной b и 
  записывает результат в глобальную же c. Сделаем следующий шаг к оптимизации: 
  пусть функция возвращает значение.
</p>
<p>
  Функция, которая ничего не принимает и возвращает результат
  Чтобы функция могла вернуть численное значение, она должна быть описана 
  с типом данных, который будет возвращаться. Нужно заранее подумать, какой 
  тип будет возвращён, чтобы избежать ошибок. Например я знаю, что моя 
  суммирующая функция работает с типом данных byte, она складывает два 
  таких числа. Это означает, что результат вполне может превысить лимит 
  на тип данных byte (сложили 100 и 200 и вот, уже 300), значит функции 
  следовало бы возвращать например тип данных int. Собственно поэтому у 
  переменной c тип данных тоже int. Для возврата значения нам понадобится 
  оператор return, который и будет возвращать число. Здесь нужно запомнить, 
  что return не просто возвращает значение, а также завершает выполнение 
  функции, то есть действия, указанные после return, выполнены уже не будут! 
  На самом деле это очень удобно, ведь с помощью логических конструкций и 
  операторов выбора можно предусмотреть в функции несколько разных return, 
  которые будут возвращать разные значения.
</p>
<p>
  Один момент: функция типа void вроде бы ничего не возвращает, но использование return позволит завершить выполнение функции по условию или как-то ещё. Это очень удобно!
  Давайте перепишем наш код так, чтобы числа a и b складывались и результат возвращался функцией, и этот результат мы уже “ручками” приравняем к c.
</p>
<p>
  byte a, b;<br>
  int c;<br>
  void setup() {<br>
    a = 10;<br>
    b = 20;<br>
    c = sumFunction();<br>
    // с имеет значение 30<br>
  }<br>
  void loop() {<br>
  }<br>
  int sumFunction() {<br>
    return (a + b);<br>
  }<br>
</p>
<p>
  Ну вот, функция стала чуть более универсальной. Теперь результат сложения a и b 
  как функцию можно использовать в других местах и приравнивать к другим переменным. 
  Чтобы сделать код ещё более универсальным, давайте передавать величины для сложения 
  в виде параметров
</p>
<p>
  Функция, которая принимает параметры и возвращает результат
  Что касается параметров, то они перечисляются в скобках через 
  запятую с указанием типа данных. При вызове функции указанные 
  параметры превращаются в локальные переменные, с которыми можно 
  работать внутри функции. При вызове функции эти переменные получают 
  значения, которые мы указываем при вызове. Смотрим:
</p>
<p>
  byte a, b;<br>
  int c;<br>
  void setup() {<br>
    a = 10;<br>
    b = 20;<br>
    c = sumFunction(a, b);<br>
    // с имеет значение 30<br>
  }<br>
  void loop() {<br>
  }<br>
  int sumFunction(byte paramA, byte paramB) {<br>
    return (paramA + paramB);<br>
  }<br>
</p>
<p>
  И вот так мы получили универсальную функцию sumFunction, которая принимает две величины 
  типа byte, складывает их и возвращает. Это и есть выполнение концепции “отделение кода от 
  данных”, функция живёт сама по себе и не зависит от других переменных! Казалось бы, можно 
  использовать функцию как sumFunction(100, 200), и она вернёт значение 300. Но не так всё 
  просто, потому что целое число по умолчанию имеет тип данных int, и при попытке передать 
  такой вот int в нашу функцию, которая принимает byte, мы получим ошибку, в которой будет 
  написано, что нельзя передать int вместо byte. В этом случае можно привести тип числа 
  к byte вручную, вот так это будет выглядеть:
</p>
<p>
  int c;<br>
  void setup() {<br>
    c = sumFunction((byte)100, (byte)200);<br>
    // с = 300<br>
  }<br>
  void loop() {<br>
  }<br>
  int sumFunction(byte paramA, byte paramB) {<br>
    return (paramA + paramB);<br>
  }<br>
</p>
<p>
  Но лучше всё-таки сделать функцию более универсальной, пусть она принимает int paramA и int paramB, 
  ведь данные переменные являются локальными, то есть создадутся при вызове функции и удалятся из памяти 
  при завершении работы функции, и их “размер” в принципе не играет роли. А как быть, если мы хотим 
  складывать уже имеющийся функцией другие типы данных? Например, float. Можно преобразовать типы данных 
  при передаче параметров, но функция всё равно вернёт целое число. Сделать нашу функцию ещё более 
  универсальной сможет такая штука C++ как перегруженная функция.
</p>
<p>
  <h2 class="contentCenter mainText">Перегруженные функции</h2>
</p>
<p>
  Перегруженная функция это такая функция, которая определена <br>
  несколько раз с одинаковым именем, но разным возвращаемым типом данных и разным набором параметров.<br>
</p>
<p>
  int c;<br>
  float d;<br>
  void setup() {<br>
    float af = 5.5;<br>
    float bf = 0.25;<br>
    Serial.begin(9600);<br>
    c = sumFunction(10, 20);      // результат 30<br>
    c = sumFunction(10, 20, 30);  // результат 60<br>
    d = sumFunction(af, bf);      // результат 5.75<br>
    Serial.println(c);<br>
    Serial.println(d);<br>
  }<br>
  void loop() {<br>
  }<br>
  int sumFunction(int paramA, int paramB) {<br>
    return (paramA + paramB);<br>
  }<br>
  int sumFunction(int paramA, int paramB, int paramC) {<br>
    return (paramA + paramB + paramC);<br>
  }<br>
  float sumFunction(float paramA, float paramB) {<br>
    return (paramA + paramB);<br>
  }<br>
</p>
<p>
  Итак, у нас теперь целых три функции с одинаковым именем, но разными наборами 
  параметров и типов возвращаемого значения. Программа сама разберётся, какую из 
  функций использовать, на основе передаваемых параметров. Передали два float – 
  работает третья функция, вернёт float. Передали три int – получили их сумму 
  при помощи второй по счёту функции. Передали два int – получили их сумму при 
  помощи первой функции. Вот такая удобная штука! Ещё одним вариантом перегруженной 
  функции является шаблонная функция, она позволяет 
  работать с данными любого типа, будучи объявлена один раз. Читайте ниже.
</p>
<p>
  Типы данных
  Функция может возвращать и принимать как параметр любые типы 
  данных в любых сочетаниях: целые числа, float, String, указатели, 
  struct, enum и так далее. Например следующая функция принимает 
  два числа, склеивает их в строку через запятую и возвращает:
</p>
<p>
  String toStr(int val1, float val2) {<br>
    return (String)val1 + ", " + val2;  <br>
  }<br>
</p>
<p>
  Далее например при вызове Serial.println(toStr(10, 3.14)) увидим в мониторе порта 10, 3.14
</p>
<p>
  Как вернуть несколько значений? (New)
  В языке C++, в отличие от того же Питона, нельзя просто так взять и вернуть из 
  функции два значения. К слову, принять их тоже нельзя, такого механизма в языке нет. 
  Но есть структуры! Функция может принять структуру, вернуть структуру, а мы можем 
  присвоить структуру. Давайте сделаем функцию, которая принимает два числа, находит их 
  сумму, разность и произведение и возвращает результат. Для начала опишем структуру:
</p>
<p>
  struct MyStruct {<br>
    int valSum;<br>
    int valSub;<br>
    int valMul;<br>
  };<br>
</p>
<p>
  Она хранит сумму, разность и произведение. Теперь сделаем функцию, которая принимает два числа, считает, забивает результат в структуру и возвращает тип данных MyStruct
</p>
<p>
  MyStruct compute(int val1, int val2) {<br>
    MyStruct str;<br>
    str.valSum = val1 + val2;<br>
    str.valSub = val1 - val2;<br>
    str.valMul = val1 * val2;<br>
    return str;<br>
  }
</p>
<p>
  Готово! Пользоваться этим можно так:
</p>
<p>
  void setup() {<br>
    Serial.begin(9600);<br>
    MyStruct str;<br>
    str = compute(3, 4);<br>
    Serial.println(str.valSum);<br>
    Serial.println(str.valSub);<br>
    Serial.println(str.valMul);<br>
  }
</p>
<p>
  Выведет в порт 7, -1, 12 Если изучить урок по типам данных, то функцию с вычислением и возвратом структуры можно сократить всего до одной строчки кода:
</p>
<p>
  MyStruct compute(int val1, int val2) {<br>
    return (MyStruct) {val1 + val2, val1 - val2, val1 * val2};<br>
  }<br>
</p>
<p>
  Описание и реализация
</p>
<p>
  Хорошим тоном считается объявлять функции отдельно от реализации. Что это значит: 
  в начале документа, или в отдельном файле, мы описываем функцию (это будет называться 
  прототип функции), а в другом месте пишем реализацию. Так делают в серьёзных программных 
  проектах, Ардуино-библиотеки – не исключение. Также такое написание позволяет слегка ускорить 
  компиляцию кода, потому что компилятор уже знает, что он в нём найдёт. Алгоритм такой: Описание (прототип) функции
</p>
<p>
  тип_данных имя_функции(набор_параметров);<br>
  Реализация функции<br>
</p>
<p>
  тип_данных имя_функции(набор_параметров) {<br>
    тело функции<br>
  }<br>
</p>
<p>
  То бишь всё то же самое, но с телом функции и фигурными скобками. Пример:
</p>
<p>
  // описание функций<br>
  void lolkek(byte cheburek);<br>
  int getMemes();<br>
  void setup() {<br>
  }<br>
  void loop() {<br>
  }<br>
  // реализация функций<br>
  int getMemes() {<br>
    // действия<br>
  }<br>
  void lolkek(byte cheburek) {<br>
    // действия<br>
  }<br>
</p>
<p>
  Примечание: хоть компилятор и позволяет вызывать функцию до её объявления (по порядку написания кода), 
  иногда он может не найти функцию и выведет ошибку “функция не объявлена”. В этом случае достаточно сделать 
  прототип функции и расположить его поближе к началу документа, да и вообще все используемые функции можно 
  сделать в виде прототипов и вынести в начало кода, вместе с глобальными переменными!
</p>
<p>
  Передача массива в функцию (Pro)
  Иногда бывает нужно передать в функцию массив (мы о них уже говорили), передать именно 
  массив целиком, а не отдельный его элемент. В этом случае уже не обойтись без указателей 
  (читай урок про указатели). В следующем примере наша функция sumFunction будет суммировать 
  элементы массива, который в неё передаётся. Функция заранее знает, сколько в массиве 
  элементов, потому что я явно цифрой указал количество в цикле for.
</p>
<p>
  int c;<br>
  int myArray[] = {100, 30, 890, 645, 251};<br>
  void setup() {<br>
    c = sumFunction(myArray);   // результат 1916<br>
  }<br>
  void loop() {<br>
  }<br>
  int sumFunction(int *intArray) {<br>
    int sum = 0;   // переменная для сложения<br>
    for (byte i = 0; i < 5; i++) {<br>
      sum += intArray[i];<br>
    }<br>
    return sum;<br>
  }<br>
</p>
<p>
  Что из этого нужно запомнить: при описании функции параметр массива указывается со звёздочкой, 
  т.е. тип_данных* имя_массива. При вызове массив передаётся как имя_массива . И в целом всё. 
  Давайте покажу как сделать универсальную функцию, которая суммирует массив любого размера. 
  Для этого нам поможет оператор sizeof(), возвращающий размер в байтах. 
  Этот размер нам нужно будет передать как аргумент функции:
</p>
<p>
  int c;<br>
  int myArray[] = {100, 30, 890, 645, 251, 645, 821, 325};<br>
  void setup() {<br>
    // передаём сам массив и его размер в БАЙТАХ<br>
    c = sumFunction(myArray, sizeof(myArray));<br>
  }<br>
  void loop() {<br>
  }<br>
  int sumFunction(int *intArray, int arrSize) {<br>
    // переменная для суммирования<br>
    int sum = 0;  <br>
    // находим размер массива, разделив его вес<br>
    // на вес одного элемента (тут у нас int)<br>
    arrSize = arrSize / sizeof(int);  <br>
    for (byte i = 0; i < arrSize; i++) {<br>
      sum += intArray[i];<br>
    }<br>
    return sum;<br>
  }<br>
</p>
<p>
  И вот мы получили функцию, которая суммирует массив типа данных int любой длины и возвращает результат.
</p>
<p>
  Важно! Переданный в функцию массив не дублирует исходный массив! 
  Любые действия, совершённые с переданным массивом, влияют на “оригинальный” массив!
  Другие типы функций (Pro)
  Шаблонные функции
  Шаблон – ещё один мощный инструмент языка C++, позволяющий создавать алгоритмы 
  без привязки к типам данных. Тема очень обширная, мы рассмотрим её только применительно к “универсальным” функциям, полностью про шаблоны можно почитать тут, и тут продолжение. Итак, шаблонные функции. В примере выше мы использовали перегруженные функции для создания функций с одинаковым именем, но разным типом передаваемых параметров. При помощи шаблонов можно сделать одну функцию, которая будет работать для всех типов данных! Компилятор сам выберет, какие типы данных подставить в функцию на этапе компиляции. Синтаксис выглядит так:
</p>
<p>
  template <параметры_шаблона> описание_функции
</p>
<p>
  Описание функции можно раскрыть:
</p>
<p>
  template <параметры_шаблона> тип_данных (аргументы) {<br>
    тело_функции<br>
  }<br>
</p>
<p>
  Сделаем функцию, которая возвращает квадрат числа любого типа<br>
</p>
<p>
  // шаблонная функция<br>
  // принимает данные любого типа<br>
  // возвращает в этом же типе<br>
  template < typename T > 
  T squareVal(T val) {<br>
    return val * val;<br>
  }<br>
  void setup() {<br>
    byte a = 10;<br>
    int b = 125;<br>
    float c = 3.14;<br>
    <br>
    a = squareVal(a);<br>
    b = squareVal(b);<br>
    c = squareVal(c);<br>
    // a == 100<br>
    // b == 15625<br>
    // c == 9.85<br>
  }<br>
</p>
<p>
  Можно передать в шаблон больше данных! Вот пример функции, которая перемножает два числа любого типа и возвращает результат:
</p>
<p>
  template<typename T1, typename T2><br>
  uint32_t mult(T1 val1, T2 val2) {<br>
    return val1 * val2;<br>
  }<br>
  void setup() {<br>
    byte a = 10;<br>
    int b = 125;<br>
    float c = 3.14;<br>
    long val = mult(a, b);<br>
    val = mult(a, c);<br>
  }<br>
</p>
<p>
  В некоторых ситуациях шаблоны могут быть очень удобны! Также при вызове шаблонной функции можно вручную передать тип данных:
</p>
<p>
  mult < byte, float > (a, c);
  </p>
  <p>
  Точно таким же образом будет работать изменение возвращаемого типа данных 
  (см. первый пример, функция возвращает шаблонный тип). Можно 
  переписать предыдущий пример функции, которая суммирует массив. 
  Преимущество шаблонной версии в том, что передавать размер массива и 
  даже тип переменной не нужно, его можно посчитать внутри функции, 
  вычислив размер через шаблон: длина массива (кол-во) = sizeof(T) / 
  sizeof(someArray[0]), то есть размер всего массива в байтах делим на размер любого элемента.
</p>
<p>
  int c;<br>
  int myArray[] = {100, 30, 890, 645, 251, 645, 821, 325};<br>
  void setup() {<br>
    // передаём массив<br>
    c = sumFunction(myArray);<br>
  }<br>
  template <typename T><br>
  int sumFunction(T &someArray) {<br>
    // переменная для суммирования<br>
    long sum = 0;<br>
    for (int i = 0; i < sizeof(T) / sizeof(someArray[0]); i++) {<br>
      sum += someArray[i];<br>
    }<br>
    return sum;<br>
  }<br>
  void loop() {}<br>
</p>
<p>
  У – удобно!
</p>
<p>
  Макро-функции
</p>
<p>
  Вы наверное уже помните такую директиву препроцессору, как #define. Из урока 
  про переменные и константы мы узнали, что при помощи дефайна можно задавать 
  константы. Ключевая особенность работы #define заключается в том, что он 
  заменяет последовательность символов чем угодно, что мы там напишем, и это 
  даёт возможность создавать так называемые макро-функции (macro), которые не 
  создаются как функции, а вставляются в код при компиляции. Например вот так 
  будет выглядеть макро, складывающая два числа:
</p>
<p>
  #define sum(x, y) ((x)+(y))
</p>
<p>
  На этапе компиляции в данном документе с кодом все встречающиеся sum(значение1, значение2) будут заменены на значение1 + значение2, таким образом это будет сумма
</p>
<p>
  #define sum(x, y) ((x)+(y))<br>
  void setup() {<br>
    byte a = 10;<br>
    byte b = 20;<br>
    byte c = sum(a, b);<br>
    // с получила значение 30<br>
    // на этапе компиляции выражение sum(a, b)<br>
    // превратилось в (a + b)<br>
    int d = sum(500, 900);<br>
    // d получила значение 1400<br>
  }<br>
  void loop() {<br>
  }<br>
</p>
<p>
  Зачем это нужно? Обычная функцию с именем, как разбиралось выше, имеет свой “адрес” 
  в памяти, и при каждом вызове функции ядро обращается к ней по этому адресу, что 
  занимает какое-то время. Макро функция же “встраивается” в код программы и выполняется 
  сразу же. В то же время, если макро-функция вызывается в нескольких местах программы, 
  она займёт больше места, чем отдельная обычная функция, т.к. все вызовы будут заменены 
  на код. Делать макросы имеет смысл на простые функции (как в примере ниже), на редко 
  вызываемые функции, и в тех местах, где важно максимальное быстродействие, т.е. 
  важен каждый такт процессора. Например в вычислительных функциях.
</p>
<p>
  “Аргументы” макро-функции нужно обязательно заключать в скобки (как (x)+(y) выше), 
  иначе работа макроса может быть непредсказуемой, если в качестве аргумента подать не одно число, а выражение.
  Также всё тело макро функции желательно брать в скобки, ( (x) + (y) ) как выше, иначе 
  можно напороться на неприятную ситуацию с порядком вычисления. Например в коде мы 
  используем sum(x, y) * 5. Макрос развернётся в (x + y) * 5. Если у тела макроса не 
  будет скобок, то получится x + y * 5, что имеет абсолютно другой смысл!
  В “языке” Arduino есть несколько готовых инструментов, которые кажутся функциями, 
  но на самом деле являются макро. Заглянем в Arduino.h и увидим следующее:
</p>
<p>
  #define min(a,b) ((a)<(b)?(a):(b))<br>
  #define max(a,b) ((a)>(b)?(a):(b))<br>
  #define abs(x) ((x)>0?(x):-(x))<br>
  #define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))<br>
  #define round(x)     ((x)>=0?(long)((x)+0.5):(long)((x)-0.5))<br>
  #define radians(deg) ((deg)*DEG_TO_RAD)<br>
  #define degrees(rad) ((rad)*RAD_TO_DEG)<br>
  #define sq(x) ((x)*(x))<br>
</p>
<p>
  Вот так вот, всем нам знакомые функции оказались макросами! 
  А ещё можно “переносить строку” для создания макро-функций с большим количеством 
  текста, перенос делается при помощи обратного слэша – \
</p>
<p>
  #define printWords()        \<br>
    Serial.print("Hello, ");  \<br>
    Serial.print("World");    \<br>
    Serial.println("!");<br>
  void setup() {<br>
    Serial.begin(9600);<br>
    printWords();<br>
  }<br>
  void loop() {}<br>
</p>
<p>
  Обратите внимание, на последней строке перенос уже не нужен! Таким образом, 
  во время работы препроцессора все вызовы “функции” printWords() будут заменены 
  на указанные строки кода. Можно аргументы таким же образом передавать:
</p>
<p>
  #define printWords(digit)     \<br>
    Serial.print("Digit is ");  \<br>
    Serial.print(digit);<br>
  void setup() {<br>
    Serial.begin(9600);<br>
    printWords(10); // выведет "Digit is 10"<br>
  }<br>
  void loop() {}<br>
</p>
<p>
  Как вы можете видеть, объявлять большую макро-функцию неудобно, и тут на помощь приходят встроенные функции.
</p>
<p>
  Встроенные функции
</p>
<p>
  Встроенная функция имеет тот же смысл, что и макро-функция: все вызовы 
  функции в коде заменяются на код внутри функции, что ускоряет быстродействие, 
  но занимает дополнительную Flash память при каждом новом вызове. В отличие от 
  макро, которая заменяется препроцессором, встроенная функция заменяется уже 
  компилятором, т.е. после работы препроцессора, об этом нужно помнить и это 
  можно использовать. Объявляется встроенная функция очень просто: достаточно 
  дописать ключевое слово inline перед объявлением функции. Компилятор может 
  отказаться встраивать функцию (зависит от его настроек), поэтому можно попросить 
  его принудительно встроить функцию при помощи атрибута __attribute__((always_inline)). 
  Таким образом, для объявления встроенной функции нужно в самом начале написать 
  inline __attribute__((always_inline)). Рассмотрим функцию, которая просто увеличивает значение переменной:
</p>
<p>
  inline __attribute__((always_inline))<br>
  int incr(int value) {<br>
    return ++value;<br>
  }<br>
</p>
<p>
  Всё! Теперь вызовы incr будут заменены на код. Если нужно разделить описание и реализацию, то можно записать так:
</p>
<p>
  // прототип<br>
  inline __attribute__((always_inline)) int incr(int value);<br>
  // реализация (будет встроенной)<br>
  int incr(int value) {<br>
    return ++value;<br>
  }
</p>
<p>
  Статические функции
</p>
<p>
  В уроке про переменные и типы данных мы обсуждали спецификатор static, который позволяет 
  скрыть глобальную переменную от других файлов программы. С функцией спецификатор static 
  делает то же самое – статическая функция скрыта от вызова из других файлов, т.е. её область о
  пределения – файл, в котором она находится. static void printHello();
</p>
<p>
  Указатель на функцию (Pro)
</p>
<p>
  Указатели – очень сложная тема, которая практически не пригодится новичку, 
  но некоторые алгоритмы знать нужно. Например передачу указателя на функцию, это 
  полезно при создании своих функций в стиле ардуиновской attachInterrupt(), в которой 
  мы указываем свою функцию, которую сами создаём, а она вызывается в другом месте. Сделать это можно так:
</p>
<p>
  void (*p_function)();   // указатель на p_function<br>
  void setup() {<br>
    Serial.begin(9600);<br>
    // прикрепляем функцию myFunction к *p_function<br>
    attachFunction(myFunction);<br>
    // вызываем p_function, которая у нас вызывает myFunction<br>
    (*p_function)();<br>
  }<br>
  void loop() {<br>
  }<br>
  void attachFunction(void (*function)()) { // передача указателя на функцию<br>
    p_function = *function;<br>
  }<br>
  void myFunction() {<br>
    Serial.println("lolkek");<br>
  }<br>
</p>